# Workbench V2 Blueprint (Reset Plan)

## Objective
Build a fast, accurate "data analyst" workflow that turns natural language into safe CRM database changes with:
- minimal LLM calls,
- deterministic matching/planning/execution logic,
- clear human confirmation before writes.

## Product Principles
- Speed: avoid model round-trips for each clarification answer.
- Accuracy: separate language understanding from database decisions.
- Safety: dry-run diffs + transactional writes + auditable logs.
- Editability: users can always modify plan steps before execution.

## Recommended System Design
Use a staged pipeline instead of a free-form chatbot loop.

1. Intake Extraction (LLM call #1)
- Input: full conversation + current model digest.
- Output: typed candidate intents, extracted entities, confidence, unresolved questions.
- No DB writes in this stage.

2. Entity Resolution (deterministic service)
- Input: extracted entity mentions.
- Output: candidate record matches with confidence + rationale.
- Policy:
  - >= 0.80: auto-use existing record.
  - 0.60-0.79: require user confirmation.
  - < 0.60: create candidate.

3. Clarification State Machine (local loop, no LLM)
- Build full question queue once from unresolved items.
- Ask one question at a time in UI.
- Store answers locally and update draft plan deterministically.

4. Plan Finalization (optional LLM call #2)
- Optional call to refine wording only.
- Final plan objects are generated by deterministic code, not free text.

5. Execution Engine (deterministic)
- Build operation DAG with dependencies.
- Run topologically, one step at a time.
- Wrap each step in transaction.
- Emit step result + audit events.

## Core Operation Contract (single internal format)
All stages should converge on one typed operation model.

```ts
type WorkbenchOperation =
  | {
      id: string;
      kind: "UPSERT_ENTITY";
      entityType: "HEALTH_SYSTEM" | "COMPANY" | "CO_INVESTOR";
      intentLabel: string;
      resolution: {
        mode: "USE_EXISTING" | "CREATE_NEW";
        existingId?: string;
        confidence?: number;
      };
      fields: Record<string, unknown>;
      issues: string[];
    }
  | {
      id: string;
      kind: "UPDATE_FIELDS";
      entityType: "HEALTH_SYSTEM" | "COMPANY" | "CO_INVESTOR";
      targetRef: { operationId?: string; existingId?: string };
      patch: Record<string, unknown>;
      issues: string[];
    }
  | {
      id: string;
      kind: "LINK_ENTITIES";
      linkType: "COMPANY_HEALTH_SYSTEM" | "COMPANY_CO_INVESTOR";
      leftRef: { operationId?: string; existingId?: string };
      rightRef: { operationId?: string; existingId?: string };
      relationshipType: string;
      fields: Record<string, unknown>;
      issues: string[];
    }
  | {
      id: string;
      kind: "ADD_CONTACT";
      parentRef: { entityType: "HEALTH_SYSTEM" | "COMPANY" | "CO_INVESTOR"; operationId?: string; existingId?: string };
      contact: {
        name: string;
        title?: string;
        email?: string;
        phone?: string;
        linkedinUrl?: string;
      };
      roleType: "EXECUTIVE" | "VENTURE_PARTNER" | "INVESTOR_PARTNER" | "COMPANY_CONTACT" | "OTHER";
      issues: string[];
    };
```

## API Shape (V2)
Prefer explicit endpoints over a single overloaded endpoint.

1. `POST /api/workbench/intake`
- Input: `{ conversation: string, mode?: "AUTO" | "STRICT" }`
- Output:
  - `candidateOperations: WorkbenchOperation[]`
  - `matchesByMention`
  - `clarificationQueue: { id, question, affectedOperationIds }[]`
  - `sessionId`

2. `POST /api/workbench/answer`
- Input: `{ sessionId, questionId, answer }`
- Output:
  - updated draft operations,
  - next question (if any),
  - `readyForPlan: boolean`.
- No LLM call required.

3. `POST /api/workbench/plan`
- Input: `{ sessionId }`
- Output:
  - executable DAG,
  - dry-run summary,
  - blocking issues.

4. `POST /api/workbench/execute`
- Input: `{ sessionId, selectedOperationIds }`
- Output:
  - step-by-step results,
  - created/updated/linked record IDs,
  - failure diagnostics.

## Deterministic Domain Rules (move from prompt into code)
Implement these as rule functions, not LLM instructions.

1. Entity typing:
- Health system and co-investor are distinct.
- Treat "innovation fund/ventures/capital" as co-investor signals.

2. Intro semantics:
- "X introduced us to Y" maps to company lead-source signal by default.
- Only create co-investor relationship when investor intent is explicit.

3. Dedupe and alias:
- Normalize names (case, punctuation, filler phrases).
- Collapse aliases such as "a company called Vitalize Care" -> "Vitalize Care".

4. Required-field policy:
- Backend fills schema-required defaults (timestamps, status, default enums).
- User is only asked business questions, never system-default boilerplate.

## Matching Service
Create a dedicated resolver per entity type:
- exact normalized name,
- alias map,
- token overlap/fuzzy similarity,
- optional website/location reinforcement.

Store and return:
- `confidence` score,
- `reasons` array,
- `recommendedAction` (`USE_EXISTING`, `NEEDS_CONFIRMATION`, `CREATE_NEW`).

## UI Flow
Chat remains the interaction shell, but planning is explicit.

1. Intake response renders:
- summary,
- auto-resolved matches,
- first clarification question.

2. Clarification loop:
- user answers one question,
- UI advances locally.

3. Plan review panel:
- editable operation list,
- dependency visualization,
- dry-run diff.

4. Execution modal:
- step progress bar,
- per-step details,
- pause/retry/skip behavior.

## Observability and Audit
Log every stage for replay/debug:
- extracted intents,
- match candidates and confidence,
- clarification Q/A transcript,
- final operation graph,
- execution result per step.

Add an `ExecutionSession` table with child `ExecutionStep` records for full traceability.

## Evaluation Harness (must-have before rollout)
Create a benchmark set from real user narratives.

Metrics:
- entity-resolution precision,
- wrong-create rate (duplicate creation),
- wrong-link rate,
- clarification turns per session,
- time-to-executable-plan,
- first-pass acceptance rate.

Gate production rollout on target thresholds for these metrics.

## Rollout Plan
Phase 1 (1-2 weeks)
- Introduce new `WorkbenchOperation` contract.
- Build resolver service and rule engine.
- Add intake endpoint returning full clarification queue.

Phase 2 (1-2 weeks)
- Add local clarification state machine in UI.
- Add plan screen with manual editing and dependency checks.

Phase 3 (1-2 weeks)
- Add execution DAG runner with transaction boundaries.
- Add audit tables and execution replay.

Phase 4 (1 week)
- Run benchmark suite.
- Tune thresholds and prompts.
- Enable for beta users only.

## Prompt Strategy (minimal but strong)
Use prompt only for extraction of intent/facts. Keep it short and strict:
- identify candidate entities and actions,
- identify uncertainty,
- never emit final DB operations without deterministic validation,
- return strict JSON.

## Why This Will Work Better
- Fewer expensive calls: usually 1 intake + 1 finalization.
- Better correctness: matching and relationship logic enforced in code.
- Better UX: one-question flow with immediate local responsiveness.
- Better maintainability: schema changes handled via typed contracts and rule layer, not prompt-only behavior.
